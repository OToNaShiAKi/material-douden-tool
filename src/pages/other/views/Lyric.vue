<template>
  <v-container>
    <v-file-input
      label="上传Aegisub文件"
      hint="若含双语歌轴，请确保样式名分别为 Defaut 和 Default - Translate"
      persistent-hint
      @change="upload"
    />
    <section class="d-flex">
      <v-text-field
        label="歌名"
        v-model="name"
        class="mr-2"
        prepend-icon="mdi-music-circle"
      />
      <v-text-field
        label="歌手"
        class="ml-2"
        v-model="singer"
        prepend-icon="mdi-account-music"
      />
    </section>
    <v-subheader class="d-flex justify-space-between">
      <span>时间轴 - 歌词 - 翻译</span>
      <v-btn color="primary" text small @click="aegisub">导出Aegisub</v-btn>
    </v-subheader>
    <section id="lyric">
      <section class="d-flex align-baseline" v-for="v of lyric" :key="v.id">
        <v-text-field
          hide-details
          type="time"
          class="flex-grow-0 flex-shrink-1"
          v-model="v.start"
          step="0.1"
        />
        <v-text-field
          hide-details
          type="time"
          class="flex-grow-0 flex-shrink-1"
          v-model="v.end"
          step="0.1"
        />
        <v-text-field v-model="v.lyric" hide-details class="ml-3" />
        <v-text-field v-model="v.tlyric" hide-details class="ml-3" />
        <v-btn @click="remove" icon small class="float-right" :data-key="v.id">
          <v-icon small :data-key="v.id">mdi-delete</v-icon>
        </v-btn>
      </section>
    </section>
    <section class="d-flex my-3 justify-space-between align-center">
      <v-btn icon color="primary" @click="add">
        <v-icon>mdi-plus</v-icon>
      </v-btn>
      <v-btn
        outlined
        small
        color="primary"
        @click="save"
        :disabled="!name || !singer"
        >保存</v-btn
      >
    </section>
    <v-chip-group column color="primary" @change="change">
      <v-chip
        v-for="v of lists"
        close
        outlined
        @click:close="close(v.id)"
        close-icon="mdi-delete"
        :key="v.id"
        :value="v.id"
      >
        {{ v.name }} - {{ v.singer }}
      </v-chip>
    </v-chip-group>
  </v-container>
</template>

<script>
import { ipcRenderer } from "electron";
import { FormatDuration } from "../../../plugins/utils";
import { Save, Get, Remove } from "../../../plugins/indexedDB";
import MD5 from "blueimp-md5";

const AssHeader = `[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+ 061
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Active Line: 7

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Default - Translate,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
const LineRegex =
  /Dialogue: \d+,(\d{1}:\d{2}:\d{2}.\d{2}),(\d{1}:\d{2}:\d{2}.\d{2}),(.*),.*,\d+,\d+,\d+,.*,(.*)/g;
const LineStart = {
  start: "00:00:00.000",
  end: "00:00:00.000",
  lyric: "",
  tlyric: "",
  id: "00:00:00.000",
};
const Reduce = (previous, value, index) =>
  previous + +value * 60 ** (2 - index);
export default {
  name: "Lyric",
  data: () => ({
    lyric: [{ ...LineStart }],
    file: null,
    name: "",
    singer: "",
    lists: [],
  }),
  props: ["music"],
  async created() {
    this.lists = await Get("music");
  },
  watch: {
    music: {
      immediate: true,
      handler(next) {
        if (next) {
          this.name = next.name;
          this.singer = next.singer;
          this.lyric = next.stamp.map(
            ({ start, lyric, tlyric, end }, index, array) => {
              if (!end && array[index + 1]) end = array[index + 1].start;
              else if (!end) {
                const duration = next.duration / 1000;
                end = FormatDuration(Math.floor(duration), true);
                end += ".";
                end += duration.toString().split(".")[1];
              }
              return { id: start, lyric, tlyric, start, end };
            }
          );
        }
      },
    },
  },
  methods: {
    add() {
      if (this.lyric.length <= 0) {
        this.lyric = [{ ...LineStart }];
        return;
      }
      let time = this.lyric[this.lyric.length - 1].start.split(":");
      time[1] = (parseInt(time[1]) + 2).toString().padStart(2, "0");
      time = time.join(":");
      this.lyric.push({
        start: time,
        end: time,
        lyric: "",
        tlyric: "",
        id: time,
      });
    },
    remove({ target }) {
      const key =
        target.dataset.key ||
        target.parentElement.dataset.key ||
        target.parentElement.parentElement.dataset.key;
      this.lyric = this.lyric.filter(({ id }) => id !== key);
    },
    aegisub() {
      let Lyric = AssHeader;
      let TranslateLyric = "";
      for (const line of this.lyric) {
        Lyric += `Dialogue: 0,${line.start},${line.end},Default,,0,0,0,,${line.lyric}\n`;
        if (line.tlyric) {
          TranslateLyric += `Dialogue: 0,${line.start},${line.end},Default - Translate,,0,0,0,,${line.tlyric}\n`;
        }
      }
      Lyric += TranslateLyric;
      const file = `${this.name} - ${this.singer}.ass`;
      ipcRenderer.send("SaveFiles", Lyric, file, "utf8");
    },
    async save() {
      const music = {
        id: this.lyric.id || MD5(`${this.name}.${this.singer}}.${Date.now()}`),
        name: this.name,
        singer: this.singer,
        lyric: "",
        tlyric: "",
        stamp: [],
        origin: "本地",
      };
      const start = this.lyric[0].start.split(":").reduce(Reduce, 0);
      const end = this.lyric[this.lyric.length - 1].end
        .split(":")
        .reduce(Reduce, 0);
      music.duration = (end - start) * 1000;
      for (const item of this.lyric) {
        music.lyric += `[${item.start}]${item.lyric}\n`;
        music.tlyric += `[${item.start}]${item.tlyric}\n`;
        music.stamp.push({
          ...item,
          stamp: item.start.split(":").reduce(Reduce, 0),
        });
      }
      music.language = match.test(item.tlyric) ? "双语" : "单语";
      await Save("music", music);
      this.lists = await Get("music");
      this.lyric = [{ ...LineStart }];
      this.singer = "";
      this.name = "";
    },
    upload(file) {
      if (file) {
        const reader = new FileReader();
        reader.addEventListener("load", ({ target: { result } }) => {
          const music = [];
          result.replace(LineRegex, (string, start, end, style, lyric) => {
            start = "0" + start + "0";
            end = "0" + end + "0";
            if (/Default( - Translate)?/.test(style)) {
              for (const item of music) {
                if (item.start === start && item.end === end) {
                  if (/Default - Translate/.test(style)) item.tlyric = lyric;
                  else if (/Default/.test(style)) item.lyric = lyric;
                  return;
                }
              }
            }
            music.push({ start, end, lyric });
          });
          this.lyric = music;
        });
        this.name = file.name;
        reader.readAsText(file);
      } else this.lyric = [{ ...LineStart }];
    },
    change(value) {
      const find = this.lists.find(({ id }) => id === value);
      this.lyric = find.stamp;
      this.lyric.id = find.id;
      this.name = find.name;
      this.singer = find.singer;
    },
    async close(key) {
      await Remove("music", key);
      this.lists = await Get("music");
    },
  },
};
</script>
