<template>
  <v-container>
    <v-file-input label="上传Aegisub文件" hint="若含双语歌轴，请确保样式名分别为 Defaut 和 Default - Translate" persistent-hint @change="upload" />
    <v-text-field
      prepend-icon="mdi-identifier"
      label="关键词"
      hint="歌名、歌手等搜索关键词以空格分割"
      v-model="keyword"
    />
    <v-subheader class="d-flex justify-space-between"
      >时间轴 - 歌词 - 翻译
      <v-btn color="primary" text small @click="aegisub">导出Aegisub</v-btn>
    </v-subheader>
    <section id="lyric">
      <section class="d-flex align-baseline" v-for="v of lyric" :key="v.id">
        <v-text-field
          hide-details
          type="time"
          class="flex-grow-0 flex-shrink-1"
          v-model="v.start"
          step="0.1"
        />
        <v-text-field
          hide-details
          type="time"
          class="flex-grow-0 flex-shrink-1"
          v-model="v.end"
          step="0.1"
        />
        <v-text-field v-model="v.lyric" hide-details class="mx-3" />
        <v-text-field v-model="v.tlyric" hide-details />
        <v-btn @click="remove" icon small class="float-right" :data-key="v.id">
          <v-icon small :data-key="v.id">mdi-delete</v-icon>
        </v-btn>
      </section>
    </section>
    <section class="d-flex my-3 justify-space-between align-center">
      <v-btn icon color="primary" @click="add">
        <v-icon>mdi-plus</v-icon>
      </v-btn>
      <v-btn outlined small color="primary"> 保存 </v-btn>
    </section>
  </v-container>
</template>

<script>
import { ipcRenderer } from "electron";
import { FormatDuration } from "../../../plugins/utils";
const AssHeader = `[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Active Line: 7

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Default - Translate,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
const LineRegex =
  /Dialogue: \d+,(\d{1}:\d{2}:\d{2}.\d{2}),(\d{1}:\d{2}:\d{2}.\d{2}),(.*),.*,\d+,\d+,\d+,.*,(.*)/g;
const LineStart = {
  start: "00:00:00.000",
  end: "",
  lyric: "",
  tlyric: "",
  id: "00:00:00.000",
};

export default {
  name: "Lyric",
  data: () => ({ lyric: [{ ...LineStart }], keyword: "", file: null }),
  props: ["music"],
  watch: {
    music: {
      immediate: true,
      handler(next) {
        if (next) {
          this.keyword = next.name + " " + next.singer;
          this.lyric = next.stamp.map(
            ({ start, lyric, tlyric, end }, index, array) => ({
              id: start,
              lyric,
              tlyric,
              start,
              end:
                end ||
                (array[index + 1]
                  ? array[index + 1].start
                  : `${FormatDuration(
                      Math.floor(next.duration / 1000),
                      true
                    )}.${(next.duration / 1000).toString().split(".")[1]}`),
            })
          );
        }
      },
    },
  },
  methods: {
    add() {
      if (this.lyric.length <= 0) {
        this.lyric = [{ ...LineStart }];
        return;
      }
      let time = this.lyric[this.lyric.length - 1].start.split(":");
      time[2] = (parseInt(time[2]) + 2).toString().padStart(2, "0");
      time = time.join(":");
      this.lyric.push({
        start: time,
        end: "",
        lyric: "",
        tlyric: "",
        id: time,
      });
    },
    remove({ target }) {
      const key =
        target.dataset.key ||
        target.parentElement.dataset.key ||
        target.parentElement.parentElement.dataset.key;
      this.lyric = this.lyric.filter(({ id }) => id !== key);
    },
    aegisub() {
      let Lyric = AssHeader;
      let TranslateLyric = "";
      for (const line of this.lyric) {
        Lyric += `Dialogue: 0,${line.start},${line.end},Default,,0,0,0,,${line.lyric}\n`;
        if (line.tlyric) {
          TranslateLyric += `Dialogue: 0,${line.start},${line.end},Default - Translate,,0,0,0,,${line.tlyric}\n`;
        }
      }
      Lyric += TranslateLyric;
      ipcRenderer.send("SaveFiles", Lyric, this.keyword + ".ass", "utf8");
    },
    upload(file) {
      if (file) {
        const reader = new FileReader();
        reader.addEventListener("load", ({ target: { result } }) => {
          const music = [];
          result.replace(LineRegex, (string, start, end, style, lyric) => {
            start = "0" + start + "0";
            end = "0" + end + "0";
            if (/Default( - Translate)?/.test(style)) {
              for (const item of music) {
                if (item.start === start && item.end === end) {
                  if (/Default - Translate/.test(style)) item.tlyric = lyric;
                  else if (/Default/.test(style)) item.lyric = lyric;
                  return
                }
              }
            }
            music.push({ start, end, lyric });
          });
          this.lyric = music;
        });
        reader.readAsText(file);
      } else this.lyric = [{ ...LineStart }];
    },
  },
};
</script>
